<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ram Thatham</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400&display=swap" rel="stylesheet" />
  <style>
    *,
    *::before,
    *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        Helvetica, Arial, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #globe-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    #globe-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      mix-blend-mode: color-dodge;
    }

    .name {
      position: fixed;
      top: 36px;
      left: 40px;
      font-family: "Chakra Petch", sans-serif;
      font-weight: 400;
      font-size: 28px;
      letter-spacing: 0.04em;
      color: #fff;
      z-index: 10;
    }

    .cursor {
      display: inline-block;
      animation: blink 1s steps(1) infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      50.01%, 100% { opacity: 0; }
    }

    .buttons {
      position: fixed;
      bottom: 40px;
      display: flex;
      gap: 24px;
      z-index: 10;
    }

    .buttons a {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 24px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 999px;
      color: #fff;
      text-decoration: none;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.02em;
      backdrop-filter: blur(8px);
      background: rgba(255, 255, 255, 0.05);
      transition: background 0.25s, border-color 0.25s, transform 0.2s;
    }

    .buttons a:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }

    .buttons a svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }
  </style>
</head>
<body>
  <div id="globe-container"></div>
  <div id="globe-overlay" role="presentation" aria-hidden="true"></div>
  <div class="name">Ram Thatham<span class="cursor">█</span></div>

  <div class="buttons">
    <a href="https://www.linkedin.com/in/ramthatham" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
      </svg>
      LinkedIn
    </a>
    <a href="https://github.com/thathamram" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
      </svg>
      GitHub
    </a>
    <a href="mailto:info@thatham.com" aria-label="Email">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"/>
      </svg>
      Email
    </a>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    (function () {
      var container = document.getElementById("globe-container");
      var overlay = document.getElementById("globe-overlay");

      // ── Main scene ──
      var scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      var camera = new THREE.PerspectiveCamera(
        45, window.innerWidth / window.innerHeight, 0.1, 1000
      );
      camera.position.z = 3.6;

      var renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // ── Overlay scene (color-dodge layer) ──
      var overlayScene = new THREE.Scene();
      var overlayRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      overlayRenderer.setSize(window.innerWidth, window.innerHeight);
      overlayRenderer.setPixelRatio(window.devicePixelRatio);
      overlayRenderer.setClearColor(0x000000, 0);
      overlay.appendChild(overlayRenderer.domElement);

      // ── Simplex noise + FBM GLSL ──
      var noiseGLSL = [
        "vec3 mod289(vec3 x){ return x - floor(x*(1.0/289.0))*289.0; }",
        "vec4 mod289(vec4 x){ return x - floor(x*(1.0/289.0))*289.0; }",
        "vec4 permute(vec4 x){ return mod289(((x*34.0)+1.0)*x); }",
        "vec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314*r; }",
        "",
        "float snoise(vec3 v){",
        "  const vec2 C = vec2(1.0/6.0, 1.0/3.0);",
        "  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);",
        "  vec3 i = floor(v + dot(v, C.yyy));",
        "  vec3 x0 = v - i + dot(i, C.xxx);",
        "  vec3 g = step(x0.yzx, x0.xyz);",
        "  vec3 l = 1.0 - g;",
        "  vec3 i1 = min(g.xyz, l.zxy);",
        "  vec3 i2 = max(g.xyz, l.zxy);",
        "  vec3 x1 = x0 - i1 + C.xxx;",
        "  vec3 x2 = x0 - i2 + C.yyy;",
        "  vec3 x3 = x0 - D.yyy;",
        "  i = mod289(i);",
        "  vec4 p = permute(permute(permute(",
        "    i.z + vec4(0.0, i1.z, i2.z, 1.0))",
        "  + i.y + vec4(0.0, i1.y, i2.y, 1.0))",
        "  + i.x + vec4(0.0, i1.x, i2.x, 1.0));",
        "  float n_ = 0.142857142857;",
        "  vec3 ns = n_ * D.wyz - D.xzx;",
        "  vec4 j = p - 49.0*floor(p*ns.z*ns.z);",
        "  vec4 x_ = floor(j*ns.z);",
        "  vec4 y_ = floor(j - 7.0*x_);",
        "  vec4 x = x_*ns.x + ns.yyyy;",
        "  vec4 y = y_*ns.x + ns.yyyy;",
        "  vec4 h = 1.0 - abs(x) - abs(y);",
        "  vec4 b0 = vec4(x.xy, y.xy);",
        "  vec4 b1 = vec4(x.zw, y.zw);",
        "  vec4 s0 = floor(b0)*2.0 + 1.0;",
        "  vec4 s1 = floor(b1)*2.0 + 1.0;",
        "  vec4 sh = -step(h, vec4(0.0));",
        "  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;",
        "  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;",
        "  vec3 p0 = vec3(a0.xy, h.x);",
        "  vec3 p1 = vec3(a0.zw, h.y);",
        "  vec3 p2 = vec3(a1.xy, h.z);",
        "  vec3 p3 = vec3(a1.zw, h.w);",
        "  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));",
        "  p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;",
        "  vec4 m = max(0.6 - vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)), 0.0);",
        "  m = m * m;",
        "  return 42.0 * dot(m*m, vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));",
        "}",
        "",
        "// 5-octave FBM",
        "float fbm(vec3 p, float seed) {",
        "  float val = 0.0;",
        "  float amp = 0.45;",
        "  float freq = 2.0;",
        "  p += seed;",
        "  for (int i = 0; i < 5; i++) {",
        "    val += snoise(p * freq) * amp;",
        "    freq *= 2.1;",
        "    amp *= 0.45;",
        "    p += 20.0;",
        "  }",
        "  return val;",
        "}"
      ].join("\n");

      // ── Wireframe vertex shader (smooth FBM displacement + mouse) ──
      var orbVertexShader = [
        "uniform float uTime;",
        "uniform float uNoiseOffset;",
        "uniform float uNoiseScale;",
        "uniform vec3 uMouse;",
        "uniform float uMouseIntensity;",
        "varying vec3 vWorldPosition;",
        "varying vec3 vViewNormal;",
        "varying float vFbmVal;",
        "",
        noiseGLSL,
        "",
        "void main() {",
        "  vec3 pos = position;",
        "  float seed = uNoiseOffset + uTime * 0.05;",
        "  vec3 timeVec = vec3(0.0, 0.0, uTime * 0.035);",
        "  vec3 p = pos + timeVec;",
        "  vec3 noiseVec = vec3(",
        "    fbm(p.yzx, seed),",
        "    fbm(p.zxy + 20.0, seed),",
        "    fbm(p.xyz + 40.0, seed)",
        "  ) * uNoiseScale;",
        "  pos += (noiseVec - 0.5 * uNoiseScale);",
        "  float mouseDist = length(position - uMouse);",
        "  float mouseEffect = smoothstep(1.8, 0.0, mouseDist) * uMouseIntensity;",
        "  pos += normal * mouseEffect * 0.18;",
        "  pos += normal * snoise(position * 4.0 + uTime * 0.25) * mouseEffect * 0.1;",
        "  vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz;",
        "  vViewNormal = normalize(normalMatrix * normal);",
        "  vFbmVal = noiseVec.x;",
        "  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);",
        "}"
      ].join("\n");

      // ── Wireframe fragment shader (visible wispy strands with color cycling) ──
      var orbFragmentShader = [
        "uniform float uTime;",
        "uniform float uOpacity;",
        "uniform vec3 uColorA;",
        "uniform vec3 uColorB;",
        "varying vec3 vWorldPosition;",
        "varying vec3 vViewNormal;",
        "varying float vFbmVal;",
        "",
        noiseGLSL,
        "",
        "void main() {",
        "  vec3 nrm = normalize(vViewNormal);",
        "  vec3 viewDir = normalize(cameraPosition - vWorldPosition);",
        "  float fresnel = 1.0 - abs(dot(nrm, viewDir));",
        "  float edge = pow(fresnel, 1.5);",
        "  float rim = pow(fresnel, 3.0);",
        "",
        "  // Very subtle breathing",
        "  float breath = sin(uTime * 0.4) * 0.5 + 0.5;",
        "",
        "  // Sweeping ring",
        "  float radialPos = length(vWorldPosition.xy);",
        "  float ringPhase = fract(uTime * 0.12);",
        "  float ringDist = abs(radialPos - ringPhase * 2.0);",
        "  float ring = smoothstep(0.25, 0.0, ringDist) * 0.35;",
        "",
        "  // Organic FBM variation",
        "  float fbmColor = fbm(vWorldPosition * 1.2, uTime * 0.04);",
        "",
        "  // Alpha — visible strands",
        "  float baseAlpha = 0.05 * (0.6 + fresnel * 0.4);",
        "  float edgeGlow = edge * 0.3;",
        "  float rimGlow = rim * 0.2;",
        "  float breathAlpha = breath * 0.005;",
        "  float totalAlpha = (baseAlpha + edgeGlow + rimGlow + breathAlpha + ring) * uOpacity;",
        "  totalAlpha = clamp(totalAlpha, 0.0, 0.8);",
        "",
        "  // Color cycling — blue → purple → magenta → cyan",
        "  float cycle = uTime * 0.08;",
        "  vec3 blue = vec3(0.15, 0.3, 0.95);",
        "  vec3 purple = vec3(0.5, 0.15, 0.85);",
        "  vec3 magenta = vec3(0.75, 0.15, 0.6);",
        "  vec3 cyan = vec3(0.1, 0.65, 0.95);",
        "  float t = fract(cycle);",
        "  vec3 baseColorA, baseColorB;",
        "  if (t < 0.25) {",
        "    baseColorA = mix(blue, purple, t * 4.0);",
        "    baseColorB = mix(purple, magenta, t * 4.0);",
        "  } else if (t < 0.5) {",
        "    baseColorA = mix(purple, magenta, (t - 0.25) * 4.0);",
        "    baseColorB = mix(magenta, cyan, (t - 0.25) * 4.0);",
        "  } else if (t < 0.75) {",
        "    baseColorA = mix(magenta, cyan, (t - 0.5) * 4.0);",
        "    baseColorB = mix(cyan, blue, (t - 0.5) * 4.0);",
        "  } else {",
        "    baseColorA = mix(cyan, blue, (t - 0.75) * 4.0);",
        "    baseColorB = mix(blue, purple, (t - 0.75) * 4.0);",
        "  }",
        "",
        "  float colorMix = fresnel * 0.4 + fbmColor * 0.35 + 0.25;",
        "  vec3 color = mix(baseColorA, baseColorB, clamp(colorMix, 0.0, 1.0));",
        "  // Cyan shimmer on rim edges",
        "  color = mix(color, cyan, rim * 0.2);",
        "  color += vec3(ring * 0.15);",
        "  // Brighten edges",
        "  color *= (0.7 + edge * 0.5 + rim * 0.7);",
        "",
        "  gl_FragColor = vec4(color, totalAlpha);",
        "}"
      ].join("\n");

      // ── Glow vertex shader ──
      var glowVertexShader = [
        "varying vec3 vNormal;",
        "void main() {",
        "  vNormal = normalize(normalMatrix * normal);",
        "  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
        "}"
      ].join("\n");

      // ── Glow fragment shader (very subtle outer halo) ──
      var glowFragmentShader = [
        "uniform float uTime;",
        "varying vec3 vNormal;",
        "void main() {",
        "  float raw = 0.5 - dot(vNormal, vec3(0.0, 0.0, 1.0));",
        "  float intensity = pow(max(raw, 0.0), 7.0);",
        "  vec3 color1 = vec3(0.06, 0.08, 0.25);",
        "  vec3 color2 = vec3(0.12, 0.04, 0.22);",
        "  float t = sin(uTime * 0.2) * 0.5 + 0.5;",
        "  vec3 glowColor = mix(color1, color2, t);",
        "  gl_FragColor = vec4(glowColor * intensity, intensity * 0.015);",
        "}"
      ].join("\n");

      // ── Overlay fragment shader (color-dodge brightening on rim strands) ──
      var overlayFragmentShader = [
        "uniform float uTime;",
        "uniform float uOpacity;",
        "uniform vec3 uColorA;",
        "uniform vec3 uColorB;",
        "varying vec3 vWorldPosition;",
        "varying vec3 vViewNormal;",
        "varying float vFbmVal;",
        "",
        noiseGLSL,
        "",
        "void main() {",
        "  vec3 nrm = normalize(vViewNormal);",
        "  vec3 viewDir = normalize(cameraPosition - vWorldPosition);",
        "  float fresnel = 1.0 - abs(dot(nrm, viewDir));",
        "  float edge = pow(fresnel, 2.0);",
        "  float rim = pow(fresnel, 3.5);",
        "",
        "  float breath = sin(uTime * 0.4) * 0.5 + 0.5;",
        "",
        "  float alpha = (edge * 0.2 + rim * 0.4 + breath * 0.003) * uOpacity;",
        "  alpha = clamp(alpha, 0.0, 0.6);",
        "",
        "  // Same color cycling as main",
        "  float cycle = uTime * 0.08;",
        "  vec3 blue = vec3(0.15, 0.3, 0.95);",
        "  vec3 purple = vec3(0.5, 0.15, 0.85);",
        "  vec3 magenta = vec3(0.75, 0.15, 0.6);",
        "  vec3 cyan = vec3(0.1, 0.65, 0.95);",
        "  float t = fract(cycle);",
        "  vec3 cA, cB;",
        "  if (t < 0.25) { cA = mix(blue, purple, t*4.0); cB = mix(purple, magenta, t*4.0); }",
        "  else if (t < 0.5) { cA = mix(purple, magenta, (t-0.25)*4.0); cB = mix(magenta, cyan, (t-0.25)*4.0); }",
        "  else if (t < 0.75) { cA = mix(magenta, cyan, (t-0.5)*4.0); cB = mix(cyan, blue, (t-0.5)*4.0); }",
        "  else { cA = mix(cyan, blue, (t-0.75)*4.0); cB = mix(blue, purple, (t-0.75)*4.0); }",
        "",
        "  float colorMix = fresnel * 0.5 + vFbmVal * 0.3 + 0.2;",
        "  vec3 color = mix(cA, cB, clamp(colorMix, 0.0, 1.0));",
        "  color = mix(color, cyan, rim * 0.2);",
        "  color *= (0.6 + rim * 1.0);",
        "",
        "  gl_FragColor = vec4(color, alpha);",
        "}"
      ].join("\n");

      // ── Create wireframe orb shells ──
      var shellConfigs = [
        { radius: 0.85, segments: 96, opacity: 0.85, noiseOffset: 0.0, noiseScale: 0.22 },
        { radius: 0.95, segments: 80, opacity: 0.65, noiseOffset: 3.3, noiseScale: 0.18 },
        { radius: 1.06, segments: 72, opacity: 0.5, noiseOffset: 6.6, noiseScale: 0.25 },
        { radius: 1.15, segments: 72, opacity: 0.25, noiseOffset: 10.0, noiseScale: 0.22 }
      ];

      var colorA = new THREE.Color(0.25, 0.15, 0.85);
      var colorB = new THREE.Color(0.6, 0.15, 0.75);

      var shells = [];
      var shellMaterials = [];

      shellConfigs.forEach(function (cfg) {
        var geo = new THREE.SphereGeometry(cfg.radius, cfg.segments, cfg.segments);
        var mat = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0.0 },
            uOpacity: { value: cfg.opacity },
            uNoiseOffset: { value: cfg.noiseOffset },
            uNoiseScale: { value: cfg.noiseScale },
            uMouse: { value: new THREE.Vector3(0, 0, 0) },
            uMouseIntensity: { value: 0.0 },
            uColorA: { value: colorA },
            uColorB: { value: colorB }
          },
          vertexShader: orbVertexShader,
          fragmentShader: orbFragmentShader,
          wireframe: true,
          blending: THREE.AdditiveBlending,
          transparent: true,
          depthWrite: false,
        });
        var mesh = new THREE.Mesh(geo, mat);
        scene.add(mesh);
        shells.push(mesh);
        shellMaterials.push(mat);
      });

      // ── Overlay wireframe shells (color-dodge brightening) ──
      var overlayShells = [];
      var overlayMaterials = [];

      shellConfigs.forEach(function (cfg) {
        var geo = new THREE.SphereGeometry(cfg.radius, cfg.segments, cfg.segments);
        var mat = new THREE.ShaderMaterial({
          uniforms: {
            uTime: { value: 0.0 },
            uOpacity: { value: cfg.opacity * 0.6 },
            uNoiseOffset: { value: cfg.noiseOffset },
            uNoiseScale: { value: cfg.noiseScale },
            uMouse: { value: new THREE.Vector3(0, 0, 0) },
            uMouseIntensity: { value: 0.0 },
            uColorA: { value: colorA },
            uColorB: { value: colorB }
          },
          vertexShader: orbVertexShader,
          fragmentShader: overlayFragmentShader,
          wireframe: true,
          blending: THREE.AdditiveBlending,
          transparent: true,
          depthWrite: false,
        });
        var mesh = new THREE.Mesh(geo, mat);
        overlayScene.add(mesh);
        overlayShells.push(mesh);
        overlayMaterials.push(mat);
      });

      // ── Glow mesh (outer halo) ──
      var glowGeometry = new THREE.SphereGeometry(1.6, 64, 64);
      var glowMaterial = new THREE.ShaderMaterial({
        uniforms: { uTime: { value: 0.0 } },
        vertexShader: glowVertexShader,
        fragmentShader: glowFragmentShader,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true,
        depthWrite: false,
      });
      scene.add(new THREE.Mesh(glowGeometry, glowMaterial));

      // ── Mouse / touch interaction (drag to spin + hover ripple) ──
      var raycaster = new THREE.Raycaster();
      var mouseNDC = new THREE.Vector2(0, 0);
      var mouseTarget = new THREE.Vector3(0, 0, 0);
      var mouseCurrent = new THREE.Vector3(0, 0, 0);
      var mouseActive = false;
      var hitSphere = new THREE.Mesh(
        new THREE.SphereGeometry(1.8, 16, 16),
        new THREE.MeshBasicMaterial({ visible: false })
      );
      scene.add(hitSphere);

      // Drag-to-spin state
      var isDragging = false;
      var dragStart = { x: 0, y: 0 };
      var dragRotation = { x: 0, y: 0 };
      var dragVelocity = { x: 0, y: 0 };
      var targetDragRotation = { x: 0, y: 0 };

      function onPointerDown(x, y) {
        isDragging = true;
        dragStart.x = x;
        dragStart.y = y;
        dragVelocity.x = 0;
        dragVelocity.y = 0;
      }

      function onPointerMove(x, y) {
        mouseNDC.x = (x / window.innerWidth) * 2 - 1;
        mouseNDC.y = -(y / window.innerHeight) * 2 + 1;
        mouseActive = true;

        if (isDragging) {
          var dx = (x - dragStart.x) * 0.005;
          var dy = (y - dragStart.y) * 0.005;
          dragVelocity.x = dx - (targetDragRotation.y - dragRotation.y);
          dragVelocity.y = dy - (targetDragRotation.x - dragRotation.x);
          targetDragRotation.y = dragRotation.y + dx;
          targetDragRotation.x = dragRotation.x + dy;
        }
      }

      function onPointerUp() {
        isDragging = false;
      }

      window.addEventListener("mousedown", function (e) {
        onPointerDown(e.clientX, e.clientY);
      });

      window.addEventListener("mousemove", function (e) {
        onPointerMove(e.clientX, e.clientY);
      }, { passive: true });

      window.addEventListener("mouseup", onPointerUp);

      window.addEventListener("touchstart", function (e) {
        if (e.touches.length > 0) {
          onPointerDown(e.touches[0].clientX, e.touches[0].clientY);
          onPointerMove(e.touches[0].clientX, e.touches[0].clientY);
        }
      }, { passive: true });

      window.addEventListener("touchmove", function (e) {
        if (e.touches.length > 0) {
          onPointerMove(e.touches[0].clientX, e.touches[0].clientY);
        }
      }, { passive: true });

      window.addEventListener("touchend", function () {
        onPointerUp();
        mouseActive = false;
      }, { passive: true });

      window.addEventListener("mouseleave", function () {
        mouseActive = false;
        isDragging = false;
      });

      var currentIntensity = 0.0;

      // Handle resize
      window.addEventListener("resize", function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        overlayRenderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        var elapsed = performance.now() * 0.001;
        glowMaterial.uniforms.uTime.value = elapsed;

        // Hover ripple (only when not dragging)
        if (mouseActive && !isDragging) {
          raycaster.setFromCamera(mouseNDC, camera);
          var hits = raycaster.intersectObject(hitSphere);
          if (hits.length > 0) {
            mouseTarget.copy(hits[0].point);
          }
        }

        var targetIntensity = (mouseActive && !isDragging) ? 1.0 : 0.0;
        currentIntensity += (targetIntensity - currentIntensity) * 0.06;
        mouseCurrent.lerp(mouseTarget, 0.08);

        // Drag rotation with smooth lerp + momentum
        if (!isDragging) {
          dragVelocity.x *= 0.95;
          dragVelocity.y *= 0.95;
          targetDragRotation.y += dragVelocity.x * 0.3;
          targetDragRotation.x += dragVelocity.y * 0.3;
        }
        dragRotation.x += (targetDragRotation.x - dragRotation.x) * 0.08;
        dragRotation.y += (targetDragRotation.y - dragRotation.y) * 0.08;

        for (var i = 0; i < shells.length; i++) {
          shellMaterials[i].uniforms.uTime.value = elapsed;
          shellMaterials[i].uniforms.uMouse.value.copy(mouseCurrent);
          shellMaterials[i].uniforms.uMouseIntensity.value = currentIntensity;

          // Gentle auto-rotation + user drag
          var autoY = elapsed * (0.03 + i * 0.008);
          var autoX = elapsed * (0.02 + i * 0.005);
          shells[i].rotation.y = autoY + dragRotation.y;
          shells[i].rotation.x = autoX + dragRotation.x;

          overlayMaterials[i].uniforms.uTime.value = elapsed;
          overlayMaterials[i].uniforms.uMouse.value.copy(mouseCurrent);
          overlayMaterials[i].uniforms.uMouseIntensity.value = currentIntensity;
          overlayShells[i].rotation.copy(shells[i].rotation);
        }

        renderer.render(scene, camera);
        overlayRenderer.render(overlayScene, camera);
      }

      animate();
    })();
  </script>
</body>
</html>
